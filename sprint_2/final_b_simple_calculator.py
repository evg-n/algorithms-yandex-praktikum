"""
-- ПРИНЦИП РАБОТЫ --
Каждый элемент входного выражения по очереди проверяется в цикле.
Если это оператор, значение сохраняется в стеке, если операция - берем два
значения из вершины стека, выполяем требуемую операцию над ними, результат
сохраняем обратно на вершину стека.


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В стеке постоянно находятся операнды, по мере обработки выражения, если
встречается одна из арифметических операций, она выполняется над двуми крайними
значениями в стеке, вместо них туда помещается результат. Таким образом, 
после обработки всех операций выражения, стек обязан содержать крайним 
элементом искомый результат.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Считывание входной строки и её разбивка на элементы - O(n),
Сам алгоритм состоит из одного цикла - O(n), на каждой итерации которого
происходят константные по сложности O(1) операцииЖ
    - проверка нахождения в множестве из 4 символов, сравнение элементов - O(1)
    - далее, одно из двух:
        - добавление в стек операнда O(1),
        - выполнение операции O(1):
            1) извлечение двух элементов,
            2) выполнение арифметической операции над ними
            3) запись результата на вершину стека
Итоговая сложность O(n).


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Помимо хранения исходного выражения (expr), алгоритм использует вспомогательную
структуру данных - стек (python list в нашей реализации), размер которого
пропорционален количеству операндов во входной строке (k). k <= n, 
где n - длина входного выражения в польской нотации.
Можно сказать, затраты по памяти - O(n).
"""


def compute(operation, operand_1, operand_2):
    if operation == "*":
        return operand_1 * operand_2
    elif operation == "+":
        return operand_1 + operand_2
    elif operation == "-":
        return operand_1 - operand_2
    else:
        return operand_1 // operand_2


def calculate(expr):
    OPERATORS = {"*", "/", "+", "-"}

    stack = []
    for item in expr:
        if item in OPERATORS:
            operand_2 = stack.pop()
            operand_1 = stack.pop()
            stack.append(compute(item, operand_1, operand_2))
        else:
            stack.append(int(item))
    return stack.pop()


def main():
    expr = input().split()
    print(calculate(expr))


if __name__ == "__main__":
    main()
